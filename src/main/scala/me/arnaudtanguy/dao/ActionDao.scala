package me.arnaudtanguy.dao

import java.util.concurrent.Executors

import com.example.models.Tables
import com.example.models.Tables._
import com.example.models.Tables.profile.api._

import scala.concurrent.{ExecutionContext, Future}

/**
 * Dao for action table
 */
trait ActionDao {
  /**
   * Find the action by ID
   * @param id the action ID
   * @return the ActionRow
   */
  def findById(id: Long): Future[Option[Tables.ActionRow]]

  /**
   * save a new action
   * @param name the action name
   * @return The action ID generated by MySQL
   */
  def save(name: String): Future[Long]
}

case class ActionDaoImpl(db: Database) extends ActionDao {
  private implicit val ec = ExecutionContext.fromExecutorService(Executors.newFixedThreadPool(5))

  override def findById(id: Long): Future[Option[Tables.ActionRow]] = {
    val query: Query[Tables.Action, Tables.Action#TableElementType, Seq] = Action.filter(_.id === id)
    val action = query.result.headOption
    db.run(action)
  }

  override def save(name: String): Future[Long] = {
    val query = Action.map(a => (a.name))
    val actions = (for {
      actionInsert <- query += (name)
      actionId <- sql"SELECT LAST_INSERT_ID()".as[(Long)].head
    } yield actionId).transactionally
    db.run(actions)
  }
}